<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Honey Meadow</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:rgba(15,23,42,.76);
      --line:rgba(255,255,255,.10);
      --text:#e5e7eb;
      --muted:#94a3b8;
      --radius:14px;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    *{box-sizing:border-box}
    html, body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(900px 600px at 20% 10%, rgba(251,191,36,.14), transparent 55%),
        radial-gradient(900px 600px at 80% 20%, rgba(96,165,250,.14), transparent 55%),
        radial-gradient(800px 600px at 50% 90%, rgba(52,211,153,.10), transparent 60%),
        var(--bg);
    }
    .wrap{max-width:1150px; margin:0 auto; padding:16px 14px 34px}
    .grid{display:grid; grid-template-columns: 1.25fr .75fr; gap:12px; align-items:start}
    @media (max-width: 980px){.grid{grid-template-columns:1fr}}
    .panel{
      border:1px solid var(--line);
      border-radius:var(--radius);
      background:var(--panel);
      padding:14px;
      backdrop-filter: blur(10px);
    }
    .panel h1{margin:0 0 8px; font-size:16px}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .btn{
      padding:9px 12px;
      border-radius:12px;
      border:1px solid var(--line);
      background:transparent;
      color:var(--text);
      cursor:pointer;
      font-weight:900;
      font-size:13px;
      transition: transform .25s cubic-bezier(.22,.61,.36,1), background .25s ease, border-color .25s ease;
    }
    .btn:hover{transform:translateY(-1px); background:rgba(255,255,255,.04)}
    .btn.primary{border-color:rgba(251,191,36,.55); background:rgba(251,191,36,.12)}
    .btn.ok{border-color:rgba(52,211,153,.55); background:rgba(52,211,153,.12)}
    .btn.danger{border-color:rgba(251,113,133,.55); background:rgba(251,113,133,.10)}
    .btn:disabled{opacity:.55; cursor:not-allowed}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-size:12px;
    }
    .pill b{color:var(--text)}
    .mono{font-family:var(--mono)}
    .status{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(11,16,32,.62);
      color:var(--muted);
    }
    .status.good{border-color:rgba(52,211,153,.55); color:var(--text)}
    .status.bad{border-color:rgba(251,113,133,.60); color:var(--text)}
    .canvasWrap{
      border:1px solid var(--line);
      border-radius:var(--radius);
      overflow:hidden;
      background:linear-gradient(180deg, rgba(17,27,51,.85), rgba(15,23,42,.75));
    }
    canvas{display:block; width:100%; height:auto; background:transparent}
    table{width:100%; border-collapse:collapse; margin-top:10px; font-size:13px}
    th, td{padding:9px 8px; border-bottom:1px solid var(--line); text-align:left; vertical-align:top}
    th{color:var(--muted); font-size:12px}
    .tabs{display:flex; gap:8px; margin-bottom:10px}
    .tabbtn{
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.02);
      color:var(--muted);
      cursor:pointer;
      font-weight:900;
      font-size:12px;
    }
    .tabbtn.active{
      color:var(--text);
      border-color:rgba(251,191,36,.55);
      background:rgba(251,191,36,.10);
    }
    .badgeCard{
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px;
      background:rgba(0,0,0,.18);
      margin-top:10px;
    }
    .badgeTop{display:flex; align-items:flex-start; justify-content:space-between; gap:10px}
    .badgeName{font-weight:950; font-size:13px}
    .badgeDesc{color:var(--muted); font-size:12px; margin-top:4px; line-height:1.45}
    .badgeRight{display:flex; align-items:center; gap:8px; flex-shrink:0}
    .check{
      width:28px; height:28px;
      border-radius:10px;
      border:1px solid var(--line);
      display:flex; align-items:center; justify-content:center;
      color:var(--muted);
      background:rgba(255,255,255,.02);
      font-weight:950;
      font-size:14px;
      line-height:1;
    }
    .check.done{
      border-color:rgba(52,211,153,.55);
      background:rgba(52,211,153,.10);
      color:var(--text);
    }
    .prog{color:var(--muted); font-size:12px; margin-top:8px}
    .adminWrap{margin-top:12px}
    .adminBox{
      border:1px dashed rgba(255,255,255,.18);
      border-radius:14px;
      padding:12px;
      background:rgba(0,0,0,.18);
    }
    .adminTitle{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      margin-bottom:10px;
      color:var(--muted);
      font-size:12px;
    }
    .input{
      padding:9px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--text);
      outline:none;
      width:140px;
      font-weight:800;
    }
    .input.small{width:120px}
    .input::placeholder{color:rgba(148,163,184,.75)}
    .adminRow{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .smallHint{color:var(--muted); font-size:12px; margin-top:8px}
    .topbar{display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:10px}
    .select{
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--text);
      outline:none;
      font-weight:900;
      font-size:12px;
      cursor:pointer;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="grid">
      <section class="panel">
        <div class="topbar">
          <h1 id="titleText" style="margin:0">Honey Meadow</h1>
          <select id="langSelect" class="select" aria-label="Language">
            <option value="ru">Русский</option>
            <option value="en">English</option>
          </select>
        </div>

        <div class="canvasWrap" aria-label="Game field">
          <canvas id="game" width="920" height="520" tabindex="0"></canvas>
        </div>

        <div class="status" id="hudPanel" style="margin-top:10px"></div>

        <div class="row" style="margin-top:10px">
          <button class="btn ok" id="btnStart" type="button"></button>
          <button class="btn" id="btnPause" type="button"></button>
          <button class="btn" id="btnAuto" type="button"></button>
          <button class="btn danger" id="btnReset" type="button"></button>
          <button class="btn primary" id="btnSave" type="button"></button>
        </div>

        <div class="status" id="playStatus"></div>

        <div class="adminWrap" id="adminWrap" style="display:none">
          <div class="adminBox">
            <div class="adminTitle">
              <span id="adminTitle"></span>
              <span class="mono">Ctrl+Shift+A</span>
            </div>

            <div class="adminRow">
              <input class="input mono" id="adminHoney" type="number" min="0" step="1" />
              <button class="btn primary" id="btnGiveHoney" type="button"></button>
              <button class="btn" id="btnAdminClose" type="button"></button>
            </div>

            <div class="adminRow" style="margin-top:10px">
              <input class="input mono small" id="adminMantisCount" type="number" min="1" step="1" />
              <input class="input mono small" id="adminMantisHp" type="number" min="1" step="1" />
              <button class="btn primary" id="btnSpawnMantis" type="button"></button>
            </div>

            <div class="smallHint" id="adminMantisLimitHint"></div>
            <div class="status" id="adminStatus" style="margin-top:10px"></div>
          </div>
        </div>
      </section>

      <section class="panel">
        <div class="tabs">
          <button class="tabbtn active" id="tabShop" type="button"></button>
          <button class="tabbtn" id="tabBadges" type="button"></button>
        </div>

        <div class="row" style="margin-bottom:10px">
          <span class="pill"><span id="lblPollen"></span> <b id="uiPollen">0</b>/<b id="uiCap">30</b></span>
          <span class="pill"><span id="lblHoney"></span> <b id="uiHoney">0</b></span>
          <span class="pill"><span id="lblBees"></span> <b id="uiBees">0</b></span>
        </div>

        <div id="shopView">
          <table aria-label="Shop">
            <thead>
              <tr>
                <th id="thUpgrade"></th>
                <th id="thEffect"></th>
                <th id="thPrice"></th>
                <th></th>
              </tr>
            </thead>
            <tbody id="shopBody"></tbody>
          </table>
          <div class="status" id="shopStatus"></div>
        </div>

        <div id="badgesView" style="display:none">
          <div class="status" id="badgesStatus"></div>
          <div id="badgesBody"></div>
        </div>
      </section>
    </div>
  </div>

<script>
"use strict";

const $ = (q) => document.querySelector(q);
const STORE_KEY = "honey_meadow_save_v12";
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const fmtInt = (n) => String(Math.max(0, Math.floor(Number(n) || 0)));

const LIMITS = { pollenCapMax: 900, moveSpeedMax: 520, gatherRateMax: 210, beesMax: 12, beePowerMax: 60 };
const ADMIN_MANTIS_MAX = 20;

const WATER_NAMES = { ru: ["нет","обычная","серебряная","золотая","алмазная"], en: ["none","basic","silver","gold","diamond"] };
const WATER_MULTS = [1.0, 1.25, 1.6, 2.1, 2.8];
const WATER_PRICES = [0, 120, 320, 750, 1600];

const INSTA_ITEM_ID = "instaConvert";
const INSTA_ITEM_PRICE = 5000;

const i18n = {
  ru: {
    start:"Старт", pause:"Пауза", reset:"Сброс", save:"Сохранить",
    autoOff:"Автоигра: выкл", autoOn:"Автоигра: ВКЛ",
    tabShop:"Магазин", tabBadges:"Бейджи",
    pollen:"Пыльца:", honey:"Мёд:", bees:"Пчёлы:",
    thUpgrade:"Улучшение", thEffect:"Эффект", thPrice:"Цена",
    shopHint:"Покупай улучшения. Прогресс сохраняется автоматически.",
    badgesHint:"Бейджи открываются по мере прогресса.",
    statusPressStart:"Нажми «Старт».",
    statusPaused:"Пауза. Нажми «Пауза» снова, чтобы продолжить.",
    statusRunning:"Игра идёт.",
    statusAutoRunning:"Автоигра: фарм + автопокупки до instat conversation.",
    mantisInactive:"богомол: неактивен (нужна пчела)",
    mantisInField:"богомол: в поле",
    mantisCd:"богомол: КД {s}s",
    hive:"УЛЕЙ",
    you:"ТЫ",
    bought:"Куплено: {name}.",
    saved:"Сохранено.",
    adminTitle:"Админ-панель (локально)",
    adminHoneyPh:"мёд",
    adminGive:"Выдать мёд",
    adminClose:"Закрыть",
    adminCountPh:"кол-во",
    adminHpPh:"HP",
    adminSpawn:"Заспавнить богомолов",
    adminLocal:"Читы локальные (только твой браузер).",
    adminLimit:"Максимум за один раз можно заспавнить: {n}.",
    adminBadHoney:"Введи число больше 0 (мёд).",
    adminOkHoney:"Выдано мёда: {n}.",
    adminOkSpawn:"Заспавнено богомолов: {c}, HP каждого: {h}.",
    maxLevel:"Максимальный уровень",
    buy:"Купить",
    instaName:"instat conversation",
    instaLocked:"Открой все бейджи, чтобы разблокировать",
    instaDescOff:"Покупаешь → подходишь к улью → вся пыльца сразу превращается в мёд",
    instaDescOn:"Мгновенная переработка в улье",
    enable:"Включить",
    disable:"Выключить",
    instaHudOn:"instat conversation: ВКЛ",
    instaHudOff:"instat conversation: выкл",
    badgeOpen:"Открыто бейджей: {a}/{b}.",
    badgeFirstMax:"Первый максимум",
    badgeFirstMaxD:"Прокачай до максимума любое улучшение.",
    badgeSerious:"Серьёзный апгрейд",
    badgeSeriousD:"Прокачай до максимума 3 улучшения.",
    badgePerfect:"Идеальный улей",
    badgePerfectD:"Прокачай до максимума всё.",
    badge1k:"Сладкая тысяча",
    badge1kD:"Получи суммарно 1 000 мёда.",
    badge10k:"Медовый магнат",
    badge10kD:"Получи суммарно 10 000 мёда.",
    badgeSpend:"Шопоголик",
    badgeSpendD:"Потрать 2 000 мёда в магазине.",
    badgeDrops:"Собиратель дропов",
    badgeDropsD:"Подбери 500 мёда с земли (дропы).",
    backpack:"Рюкзак",
    boots:"Сапожки",
    gloves:"Перчатки",
    bee:"Пчела",
    signal:"Мёд-сигнал",
    watering:"Поливалка",
    capEffect:"+15 вместимости (сейчас {cur} / {max})",
    capMax:"{ml}: вместимость {cur}",
    speedEffect:"+25 скорость (сейчас {cur} / {max})",
    speedMax:"{ml}: скорость {cur}",
    gatherEffect:"+6 сбор/с (сейчас {cur} / {max})",
    gatherMax:"{ml}: сбор {cur}/с",
    beeEffect:"+1 пчела (сейчас {cur} / {max})",
    beeMax:"{ml}: пчёл {cur}",
    signalEffect:"+3 сила пчёл (сейчас {cur} / {max})",
    signalMax:"{ml}: сила {cur} (≈{dps}/с урона)",
    wateringMax:"{ml}: {name} (реген x{m})",
    wateringNext:"Следующая: {name} (реген x{m}), сейчас x{curm}",
    dash:"—"
  },
  en: {
    start:"Start", pause:"Pause", reset:"Reset", save:"Save",
    autoOff:"Auto: off", autoOn:"Auto: ON",
    tabShop:"Shop", tabBadges:"Badges",
    pollen:"Pollen:", honey:"Honey:", bees:"Bees:",
    thUpgrade:"Upgrade", thEffect:"Effect", thPrice:"Price",
    shopHint:"Buy upgrades. Progress auto-saves.",
    badgesHint:"Badges unlock as you progress.",
    statusPressStart:"Press “Start”.",
    statusPaused:"Paused. Press “Pause” again to resume.",
    statusRunning:"Game running.",
    statusAutoRunning:"Auto: farm + auto-buy until instat conversation.",
    mantisInactive:"mantis: inactive (need a bee)",
    mantisInField:"mantis: on field",
    mantisCd:"mantis: CD {s}s",
    hive:"HIVE",
    you:"YOU",
    bought:"Bought: {name}.",
    saved:"Saved.",
    adminTitle:"Admin panel (local)",
    adminHoneyPh:"honey",
    adminGive:"Give honey",
    adminClose:"Close",
    adminCountPh:"count",
    adminHpPh:"HP",
    adminSpawn:"Spawn mantises",
    adminLocal:"Local cheats (this browser only).",
    adminLimit:"Max spawn per click: {n}.",
    adminBadHoney:"Enter a number greater than 0 (honey).",
    adminOkHoney:"Honey given: {n}.",
    adminOkSpawn:"Spawned: {c}, HP each: {h}.",
    maxLevel:"Max level",
    buy:"Buy",
    instaName:"instat conversation",
    instaLocked:"Unlock all badges to unlock",
    instaDescOff:"Buy → go to hive → all pollen instantly converts to honey",
    instaDescOn:"Instant hive conversion",
    enable:"Enable",
    disable:"Disable",
    instaHudOn:"instat conversation: ON",
    instaHudOff:"instat conversation: off",
    badgeOpen:"Badges unlocked: {a}/{b}.",
    badgeFirstMax:"First max",
    badgeFirstMaxD:"Max out any upgrade.",
    badgeSerious:"Serious upgrade",
    badgeSeriousD:"Max out 3 upgrades.",
    badgePerfect:"Perfect hive",
    badgePerfectD:"Max out everything.",
    badge1k:"Sweet thousand",
    badge1kD:"Earn 1,000 total honey.",
    badge10k:"Honey tycoon",
    badge10kD:"Earn 10,000 total honey.",
    badgeSpend:"Shopaholic",
    badgeSpendD:"Spend 2,000 honey in the shop.",
    badgeDrops:"Drop collector",
    badgeDropsD:"Pick up 500 honey from drops.",
    backpack:"Backpack",
    boots:"Boots",
    gloves:"Gloves",
    bee:"Bee",
    signal:"Honey signal",
    watering:"Watering can",
    capEffect:"+15 capacity (now {cur} / {max})",
    capMax:"{ml}: capacity {cur}",
    speedEffect:"+25 speed (now {cur} / {max})",
    speedMax:"{ml}: speed {cur}",
    gatherEffect:"+6 gather/s (now {cur} / {max})",
    gatherMax:"{ml}: gather {cur}/s",
    beeEffect:"+1 bee (now {cur} / {max})",
    beeMax:"{ml}: bees {cur}",
    signalEffect:"+3 bee power (now {cur} / {max})",
    signalMax:"{ml}: power {cur} (≈{dps}/s damage)",
    wateringMax:"{ml}: {name} (regen x{m})",
    wateringNext:"Next: {name} (regen x{m}), now x{curm}",
    dash:"—"
  }
};

const state = {
  lang: "en",
  running: false,
  paused: false,
  autoPlay: false,
  autoBuy: true,
  autoMode: "flower",
  autoModeSince: 0,
  pollen: 0,
  pollenCap: 30,
  honey: 0,
  moveSpeed: 190,
  gatherRate: 22,
  wateringLevel: 0,
  wateringMult: 1.0,
  bees: 0,
  beePower: 8,
  instaOwned: false,
  instaEnabled: false,
  stats: { honeyEarnedTotal: 0, honeyFromConvert: 0, honeyFromDrops: 0, honeyFromAdmin: 0, honeySpent: 0 },
  player: { x: 140, y: 340, r: 12 },
  hive:   { x: 140, y: 95,  r: 18 },
  flowers: [],
  mobs: [],
  drops: [],
  mantisCooldownMs: 40000,
  lastMantisSpawnTs: 0,
  keys: { up:false, down:false, left:false, right:false, space:false },
  lastTs: 0,
  lastAutoSave: 0,
  lastAutoBuyTs: 0,
  uiLastHoney: -1,
  uiLastPollen: -1,
  uiLastCap: -1,
  uiLastBees: -1,
  uiLastHoneyRendered: -1,
  uiLastBadgeKey: "",
  uiTab: "shop"
};

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function t(key, vars){
  const dict = i18n[state.lang] || i18n.ru;
  let s = dict[key] ?? key;
  if(vars){
    for(const k of Object.keys(vars)){
      s = s.replaceAll("{" + k + "}", String(vars[k]));
    }
  }
  return s;
}

// ✅ FIX: раньше этой функции не было, поэтому и падало updatePlayStatus is not defined
function updatePlayStatus(){
  const el = $("#playStatus");
  if(!el) return;

  let text = t("statusPressStart");
  let good = false;

  if(state.running){
    if(state.paused){
      text = t("statusPaused");
    } else {
      text = state.autoPlay ? t("statusAutoRunning") : t("statusRunning");
      good = true;
    }
  }

  el.textContent = text;
  el.className = "status" + (good ? " good" : "");
}

function setStaticText(){
  $("#btnStart").textContent = t("start");
  $("#btnPause").textContent = t("pause");
  $("#btnReset").textContent = t("reset");
  $("#btnSave").textContent = t("save");
  $("#tabShop").textContent = t("tabShop");
  $("#tabBadges").textContent = t("tabBadges");
  $("#lblPollen").textContent = t("pollen");
  $("#lblHoney").textContent = t("honey");
  $("#lblBees").textContent = t("bees");
  $("#thUpgrade").textContent = t("thUpgrade");
  $("#thEffect").textContent = t("thEffect");
  $("#thPrice").textContent = t("thPrice");
  $("#shopStatus").textContent = t("shopHint");
  $("#badgesStatus").textContent = t("badgesHint");
  $("#adminTitle").textContent = t("adminTitle");
  $("#adminHoney").placeholder = t("adminHoneyPh");
  $("#btnGiveHoney").textContent = t("adminGive");
  $("#btnAdminClose").textContent = t("adminClose");
  $("#adminMantisCount").placeholder = t("adminCountPh");
  $("#adminMantisHp").placeholder = t("adminHpPh");
  $("#btnSpawnMantis").textContent = t("adminSpawn");
  $("#adminStatus").textContent = t("adminLocal");
  $("#adminMantisLimitHint").textContent = t("adminLimit", { n: ADMIN_MANTIS_MAX });
  $("#btnAuto").textContent = state.autoPlay ? t("autoOn") : t("autoOff");
  updatePlayStatus();
}

function resizeCanvas(){
  const wrap = canvas.parentElement;
  if(!wrap) return;
  const rect = wrap.getBoundingClientRect();
  const targetW = Math.max(520, Math.min(920, Math.floor(rect.width)));
  const aspect = 920 / 520;
  const targetH = Math.floor(targetW / aspect);
  canvas.width = targetW;
  canvas.height = targetH;
  state.hive.x = 140;
  state.hive.y = 95;
  state.player.x = clamp(state.player.x, 20, canvas.width - 20);
  state.player.y = clamp(state.player.y, 20, canvas.height - 20);
}

function dist2(ax, ay, bx, by){
  const dx = ax - bx;
  const dy = ay - by;
  return dx*dx + dy*dy;
}

function makeFlower(x, y, rarity){
  const baseMax = rarity === "legendary" ? 360 : (rarity === "epic" ? 240 : (rarity === "rare" ? 150 : 95));
  const regen = rarity === "legendary" ? 14.5 : (rarity === "epic" ? 10.5 : (rarity === "rare" ? 7.5 : 5.5));
  return { x, y, r: rarity === "legendary" ? 20 : (rarity === "epic" ? 18 : (rarity === "rare" ? 16 : 14)), max: baseMax, pollen: baseMax, regen, rarity };
}

function rollRarity(){
  const roll = Math.random();
  if(roll > 0.985) return "legendary";
  if(roll > 0.92) return "epic";
  if(roll > 0.78) return "rare";
  return "common";
}

function seedField(){
  const W = canvas.width;
  const H = canvas.height;
  const count = 18;
  const leftPad = 240;
  const rightPad = 30;
  const topPad = 70;
  const bottomPad = 40;
  const minDist = 54;
  const flowers = [];
  const hiveSafe = (state.hive.r + 60);
  const playerSafe = (state.player.r + 60);
  let attempts = 0;

  while(flowers.length < count && attempts < 4000){
    attempts++;
    const x = leftPad + Math.random() * (W - leftPad - rightPad);
    const y = topPad + Math.random() * (H - topPad - bottomPad);
    if(dist2(x, y, state.hive.x, state.hive.y) < hiveSafe * hiveSafe) continue;
    if(dist2(x, y, state.player.x, state.player.y) < playerSafe * playerSafe) continue;
    let ok = true;
    for(const f of flowers){
      if(dist2(x, y, f.x, f.y) < minDist * minDist){ ok = false; break; }
    }
    if(!ok) continue;
    const forcedLegendary = (flowers.length === 0);
    const rarity = forcedLegendary ? "legendary" : rollRarity();
    flowers.push(makeFlower(x, y, rarity));
  }
  state.flowers = flowers;
}

function nearestFlower(px, py){
  let best = null;
  let bestD = Infinity;
  for(const f of state.flowers){
    const d = dist2(px, py, f.x, f.y);
    if(d < bestD){ bestD = d; best = f; }
  }
  return { f: best, d2: bestD };
}

function nearestMob(px, py){
  let best = null;
  let bestD = Infinity;
  for(const m of state.mobs){
    const d = dist2(px, py, m.x, m.y);
    if(d < bestD){ bestD = d; best = m; }
  }
  return { m: best, d2: bestD };
}

function nearestDrop(px, py){
  let best = null;
  let bestD = Infinity;
  for(const d of state.drops){
    const dd = dist2(px, py, d.x, d.y);
    if(dd < bestD){ bestD = dd; best = d; }
  }
  return { d: best, d2: bestD };
}

function persist(){
  localStorage.setItem(STORE_KEY, JSON.stringify({
    lang: state.lang,
    autoPlay: state.autoPlay,
    pollen: state.pollen,
    pollenCap: state.pollenCap,
    honey: state.honey,
    moveSpeed: state.moveSpeed,
    gatherRate: state.gatherRate,
    wateringLevel: state.wateringLevel,
    wateringMult: state.wateringMult,
    bees: state.bees,
    beePower: state.beePower,
    instaOwned: state.instaOwned,
    instaEnabled: state.instaEnabled,
    stats: state.stats
  }));
}

function load(){
  try{
    const raw = localStorage.getItem(STORE_KEY);
    if(!raw) return false;
    const data = JSON.parse(raw);

    state.lang = (data.lang === "en" || data.lang === "ru") ? data.lang : state.lang;
    state.autoPlay = !!data.autoPlay;

    state.pollen = Number(data.pollen) || 0;
    state.pollenCap = Number(data.pollenCap) || state.pollenCap;
    state.honey = Number(data.honey) || 0;
    state.moveSpeed = Number(data.moveSpeed) || state.moveSpeed;
    state.gatherRate = Number(data.gatherRate) || state.gatherRate;

    state.wateringLevel = Number(data.wateringLevel) || 0;
    state.wateringMult = Number(data.wateringMult) || 1.0;

    state.bees = Number(data.bees) || 0;
    state.beePower = Number(data.beePower) || state.beePower;

    state.instaOwned = !!data.instaOwned;
    state.instaEnabled = !!data.instaEnabled;

    if(data.stats && typeof data.stats === "object"){
      state.stats.honeyEarnedTotal = Number(data.stats.honeyEarnedTotal) || 0;
      state.stats.honeyFromConvert = Number(data.stats.honeyFromConvert) || 0;
      state.stats.honeyFromDrops = Number(data.stats.honeyFromDrops) || 0;
      state.stats.honeyFromAdmin = Number(data.stats.honeyFromAdmin) || 0;
      state.stats.honeySpent = Number(data.stats.honeySpent) || 0;
    }

    state.pollenCap = clamp(state.pollenCap, 30, LIMITS.pollenCapMax);
    state.moveSpeed = clamp(state.moveSpeed, 190, LIMITS.moveSpeedMax);
    state.gatherRate = clamp(state.gatherRate, 22, LIMITS.gatherRateMax);
    state.bees = clamp(state.bees, 0, LIMITS.beesMax);
    state.beePower = clamp(state.beePower, 8, LIMITS.beePowerMax);
    state.wateringLevel = clamp(state.wateringLevel, 0, 4);
    state.wateringMult = WATER_MULTS[state.wateringLevel] || 1.0;

    return true;
  } catch {
    return false;
  }
}

function addHoney(amount, source){
  const a = Math.max(0, Number(amount) || 0);
  if(a <= 0) return;
  state.honey += a;
  state.stats.honeyEarnedTotal += a;
  if(source === "convert") state.stats.honeyFromConvert += a;
  if(source === "drops") state.stats.honeyFromDrops += a;
  if(source === "admin") state.stats.honeyFromAdmin += a;
}

function maxedCount(){
  let c = 0;
  if(state.pollenCap >= LIMITS.pollenCapMax) c++;
  if(state.moveSpeed >= LIMITS.moveSpeedMax) c++;
  if(state.gatherRate >= LIMITS.gatherRateMax) c++;
  if(state.bees >= LIMITS.beesMax) c++;
  if(state.beePower >= LIMITS.beePowerMax) c++;
  if(state.wateringLevel >= 4) c++;
  return c;
}

function isMaxedAll(){
  return (
    state.pollenCap >= LIMITS.pollenCapMax &&
    state.moveSpeed >= LIMITS.moveSpeedMax &&
    state.gatherRate >= LIMITS.gatherRateMax &&
    state.bees >= LIMITS.beesMax &&
    state.beePower >= LIMITS.beePowerMax &&
    state.wateringLevel >= 4
  );
}

const badges = [
  { id:"max_one",   nameKey:"badgeFirstMax", descKey:"badgeFirstMaxD", done: () => maxedCount() >= 1, progressText: () => `${maxedCount()}/1` },
  { id:"max_three", nameKey:"badgeSerious",  descKey:"badgeSeriousD",  done: () => maxedCount() >= 3, progressText: () => `${maxedCount()}/3` },
  { id:"max_all",   nameKey:"badgePerfect",  descKey:"badgePerfectD",  done: () => isMaxedAll(),      progressText: () => `${maxedCount()}/6` },
  { id:"honey_1k",  nameKey:"badge1k",       descKey:"badge1kD",       done: () => state.stats.honeyEarnedTotal >= 1000,  progressText: () => `${fmtInt(state.stats.honeyEarnedTotal)}/1000` },
  { id:"honey_10k", nameKey:"badge10k",      descKey:"badge10kD",      done: () => state.stats.honeyEarnedTotal >= 10000, progressText: () => `${fmtInt(state.stats.honeyEarnedTotal)}/10000` },
  { id:"spender_2k",nameKey:"badgeSpend",    descKey:"badgeSpendD",    done: () => state.stats.honeySpent >= 2000,        progressText: () => `${fmtInt(state.stats.honeySpent)}/2000` },
  { id:"drops_500", nameKey:"badgeDrops",    descKey:"badgeDropsD",    done: () => state.stats.honeyFromDrops >= 500,     progressText: () => `${fmtInt(state.stats.honeyFromDrops)}/500` }
];

function allBadgesDone(){
  return badges.every(b => b.done());
}

function badgesStateKey(){
  return [
    maxedCount(),
    Math.floor(state.stats.honeyEarnedTotal),
    Math.floor(state.stats.honeySpent),
    Math.floor(state.stats.honeyFromDrops),
    state.instaOwned ? 1 : 0,
    state.instaEnabled ? 1 : 0,
    state.lang,
    state.autoPlay ? 1 : 0,
    Math.floor(state.pollen),
    state.mobs.length
  ].join("|");
}

const shopItems = [
  {
    id: "cap",
    nameKey: "backpack",
    maxed: () => state.pollenCap >= LIMITS.pollenCapMax,
    effect: () => state.pollenCap >= LIMITS.pollenCapMax
      ? `${t("maxLevel")}: ${fmtInt(state.pollenCap)}`
      : t("capEffect", { cur: fmtInt(state.pollenCap), max: fmtInt(LIMITS.pollenCapMax) }),
    price: () => 35 + Math.floor((state.pollenCap - 30) / 15) * 25,
    buy: () => { state.pollenCap = clamp(state.pollenCap + 15, 30, LIMITS.pollenCapMax); }
  },
  {
    id: "speed",
    nameKey: "boots",
    maxed: () => state.moveSpeed >= LIMITS.moveSpeedMax,
    effect: () => state.moveSpeed >= LIMITS.moveSpeedMax
      ? `${t("maxLevel")}: ${fmtInt(state.moveSpeed)}`
      : t("speedEffect", { cur: fmtInt(state.moveSpeed), max: fmtInt(LIMITS.moveSpeedMax) }),
    price: () => 40 + Math.floor((state.moveSpeed - 190) / 25) * 30,
    buy: () => { state.moveSpeed = clamp(state.moveSpeed + 25, 190, LIMITS.moveSpeedMax); }
  },
  {
    id: "gather",
    nameKey: "gloves",
    maxed: () => state.gatherRate >= LIMITS.gatherRateMax,
    effect: () => state.gatherRate >= LIMITS.gatherRateMax
      ? `${t("maxLevel")}: ${fmtInt(state.gatherRate)}/s`
      : t("gatherEffect", { cur: fmtInt(state.gatherRate), max: fmtInt(LIMITS.gatherRateMax) }),
    price: () => 45 + Math.floor((state.gatherRate - 22) / 6) * 35,
    buy: () => { state.gatherRate = clamp(state.gatherRate + 6, 22, LIMITS.gatherRateMax); }
  },
  {
    id: "bee",
    nameKey: "bee",
    maxed: () => state.bees >= LIMITS.beesMax,
    effect: () => state.bees >= LIMITS.beesMax
      ? `${t("maxLevel")}: ${fmtInt(state.bees)}`
      : t("beeEffect", { cur: fmtInt(state.bees), max: fmtInt(LIMITS.beesMax) }),
    price: () => 70 + state.bees * 55,
    buy: () => { state.bees = clamp(state.bees + 1, 0, LIMITS.beesMax); }
  },
  {
    id: "beePower",
    nameKey: "signal",
    maxed: () => state.beePower >= LIMITS.beePowerMax,
    effect: () => {
      const dps = (state.bees * state.beePower) * 0.55;
      if(state.beePower >= LIMITS.beePowerMax){
        return `${t("maxLevel")}: ${fmtInt(state.beePower)} (≈${fmtInt(dps)}/s)`;
      }
      return t("signalEffect", { cur: fmtInt(state.beePower), max: fmtInt(LIMITS.beePowerMax) });
    },
    price: () => 85 + Math.floor((state.beePower - 8) / 3) * 60,
    buy: () => { state.beePower = clamp(state.beePower + 3, 8, LIMITS.beePowerMax); }
  },
  {
    id: "watering",
    nameKey: "watering",
    maxed: () => state.wateringLevel >= 4,
    effect: () => {
      const names = WATER_NAMES[state.lang] || WATER_NAMES.ru;
      if(state.wateringLevel >= 4){
        return `${t("maxLevel")}: ${names[4]} (x${WATER_MULTS[4]})`;
      }
      const next = state.wateringLevel + 1;
      return t("wateringNext", { name: names[next], m: WATER_MULTS[next], curm: WATER_MULTS[state.wateringLevel] });
    },
    price: () => {
      const next = state.wateringLevel + 1;
      if(next > 4) return 0;
      return WATER_PRICES[next];
    },
    buy: () => {
      state.wateringLevel = clamp(state.wateringLevel + 1, 0, 4);
      state.wateringMult = WATER_MULTS[state.wateringLevel] || 1.0;
    }
  }
];

function renderShop(){
  const body = $("#shopBody");
  const honey = Math.floor(state.honey);
  const unlockedInsta = allBadgesDone();
  const rows = [];

  for(const item of shopItems){
    const maxed = item.maxed ? item.maxed() : false;
    const price = maxed ? 0 : item.price();
    const affordable = (!maxed) && honey >= price;

    const priceCell = maxed
      ? `<span class="pill" style="padding:5px 9px"><b>—</b></span>`
      : `<span class="pill" style="padding:5px 9px"><b>${fmtInt(price)}</b></span>`;

    const actionCell = maxed
      ? ``
      : `<button class="btn ${affordable ? "primary" : ""}" data-buy="${item.id}" ${affordable ? "" : "disabled"} type="button">${t("buy")}</button>`;

    rows.push(`
      <tr>
        <td><b>${t(item.nameKey)}</b></td>
        <td style="color:var(--muted)">${item.effect()}</td>
        <td>${priceCell}</td>
        <td style="text-align:right">${actionCell}</td>
      </tr>
    `);
  }

  if(unlockedInsta){
    if(!state.instaOwned){
      const affordable = honey >= INSTA_ITEM_PRICE;
      rows.push(`
        <tr>
          <td><b>${t("instaName")}</b></td>
          <td style="color:var(--muted)">${t("instaDescOff")}</td>
          <td><span class="pill" style="padding:5px 9px"><b>${fmtInt(INSTA_ITEM_PRICE)}</b></span></td>
          <td style="text-align:right">
            <button class="btn ${affordable ? "primary" : ""}" data-buy="${INSTA_ITEM_ID}" ${affordable ? "" : "disabled"} type="button">${t("buy")}</button>
          </td>
        </tr>
      `);
    } else {
      rows.push(`
        <tr>
          <td><b>${t("instaName")}</b></td>
          <td style="color:var(--muted)">${t("instaDescOn")}: <b>${state.instaEnabled ? "ON" : "OFF"}</b></td>
          <td><span class="pill" style="padding:5px 9px"><b>—</b></span></td>
          <td style="text-align:right">
            <button class="btn primary" data-toggle-insta="1" type="button">${state.instaEnabled ? t("disable") : t("enable")}</button>
          </td>
        </tr>
      `);
    }
  } else {
    rows.push(`
      <tr>
        <td><b>${t("instaName")}</b></td>
        <td style="color:var(--muted)">${t("instaLocked")}</td>
        <td><span class="pill" style="padding:5px 9px"><b>—</b></span></td>
        <td style="text-align:right"></td>
      </tr>
    `);
  }

  body.innerHTML = rows.join("");
  state.uiLastHoneyRendered = honey;
}

function renderBadges(){
  const wrap = $("#badgesBody");
  wrap.innerHTML = badges.map(b => {
    const done = !!b.done();
    const prog = b.progressText ? b.progressText() : (done ? "OK" : "...");
    return `
      <div class="badgeCard">
        <div class="badgeTop">
          <div>
            <div class="badgeName">${t(b.nameKey)}</div>
            <div class="badgeDesc">${t(b.descKey)}</div>
            <div class="prog">${prog}</div>
          </div>
          <div class="badgeRight">
            <div class="check ${done ? "done" : ""}">${done ? "✓" : "✗"}</div>
          </div>
        </div>
      </div>
    `;
  }).join("");

  const doneCount = badges.filter(b => b.done()).length;
  const s = $("#badgesStatus");
  s.className = "status" + (doneCount ? " good" : "");
  s.textContent = t("badgeOpen", { a: doneCount, b: badges.length });
}

function syncUI(forceAll){
  const pollen = Math.floor(state.pollen);
  const cap = Math.floor(state.pollenCap);
  const honey = Math.floor(state.honey);
  const beesN = Math.floor(state.bees);

  if(pollen !== state.uiLastPollen){ $("#uiPollen").textContent = fmtInt(pollen); state.uiLastPollen = pollen; }
  if(cap !== state.uiLastCap){ $("#uiCap").textContent = fmtInt(cap); state.uiLastCap = cap; }
  if(honey !== state.uiLastHoney){ $("#uiHoney").textContent = fmtInt(honey); state.uiLastHoney = honey; }
  if(beesN !== state.uiLastBees){ $("#uiBees").textContent = fmtInt(beesN); state.uiLastBees = beesN; }

  const badgeKey = badgesStateKey();
  const shouldRenderBadges = forceAll || (badgeKey !== state.uiLastBadgeKey) || (state.uiTab === "badges");
  const shouldRenderShop = forceAll || (honey !== state.uiLastHoneyRendered) || (badgeKey !== state.uiLastBadgeKey);

  if(shouldRenderShop) renderShop();
  if(shouldRenderBadges){
    renderBadges();
    state.uiLastBadgeKey = badgeKey;
  }
}

function setTab(tab){
  state.uiTab = tab;
  $("#tabShop").classList.toggle("active", tab === "shop");
  $("#tabBadges").classList.toggle("active", tab === "badges");
  $("#shopView").style.display = (tab === "shop") ? "" : "none";
  $("#badgesView").style.display = (tab === "badges") ? "" : "none";
  if(tab === "badges") syncUI(true);
}

function spawnMantis(ts, hpOverride){
  const W = canvas.width;
  const H = canvas.height;
  const x = W - 60;
  const y = 120 + Math.random() * (H - 170);
  const hp = Math.max(1, Math.floor(Number(hpOverride) || 120));
  const m = { type:"mantis", x, y, r:18, hp, hpMax:hp, speed:55 + Math.random()*20, wobble:Math.random()*Math.PI*2, alive:true, bornTs:ts };
  state.mobs.push(m);
  state.lastMantisSpawnTs = ts;
}

function dropHoney(x, y){
  const amount = 8 + Math.floor(Math.random() * 29);
  state.drops.push({ x, y, r: 10, amount, born: performance.now(), ttl: 14000 });
}

function vecNorm(x, y){
  const m = Math.hypot(x, y) || 1;
  return { x: x / m, y: y / m, m };
}

function chooseBestFlower(px, py){
  let best = null;
  let bestScore = -Infinity;
  for(const f of state.flowers){
    if(f.pollen <= 0.5) continue;
    const d = Math.hypot(f.x - px, f.y - py) || 1;
    let rarityW = 1.0;
    if(f.rarity === "rare") rarityW = 1.15;
    if(f.rarity === "epic") rarityW = 1.35;
    if(f.rarity === "legendary") rarityW = 1.55;
    const score = (f.pollen / f.max) * rarityW * (1 / (0.6 + d / 260));
    if(score > bestScore){ bestScore = score; best = f; }
  }
  return best;
}

function setAutoMode(mode, ts){
  if(state.autoMode !== mode){
    state.autoMode = mode;
    state.autoModeSince = ts;
  }
}

function isInHive(){
  const p = state.player;
  const h = state.hive;
  const hiveRange = (p.r + h.r + 12);
  return dist2(p.x, p.y, h.x, h.y) <= hiveRange * hiveRange;
}

function aiSteer(dt, ts){
  const p = state.player;
  const inHive = isInHive();

  if(inHive && state.pollen > 0){
    setAutoMode("hiveHold", ts);
  } else if(state.autoMode === "hiveHold" && state.pollen <= 0.01){
    setAutoMode("flower", ts);
  }

  const lockMs = 450;
  const locked = (ts - (state.autoModeSince || 0)) < lockMs;

  const nd = nearestDrop(p.x, p.y);
  const hasDrop = !!nd.d;

  const wantHive = (state.instaOwned && state.instaEnabled)
    ? (state.pollen > 0)
    : (state.pollen >= state.pollenCap * 0.9);

  let desired = state.autoMode;

  if(state.autoMode !== "hiveHold"){
    if(hasDrop && Math.sqrt(nd.d2) < 520){
      desired = "drop";
    } else if(wantHive){
      desired = "hive";
    } else {
      desired = "flower";
    }
  } else {
    desired = "hiveHold";
  }

  if(!locked) setAutoMode(desired, ts);

  let avoidX = 0, avoidY = 0;
  if(state.mobs.length){
    const nm = nearestMob(p.x, p.y);
    if(nm.m){
      const m = nm.m;
      const d = Math.sqrt(nm.d2);
      const danger = 170;
      if(d < danger){
        const away = vecNorm(p.x - m.x, p.y - m.y);
        const w = (danger - d) / danger;
        avoidX += away.x * (1.8 * w);
        avoidY += away.y * (1.8 * w);
      }
    }
  }

  let tx = p.x, ty = p.y;

  if(state.autoMode === "hiveHold" || state.autoMode === "hive"){
    tx = state.hive.x; ty = state.hive.y;
  } else if(state.autoMode === "drop" && hasDrop){
    tx = nd.d.x; ty = nd.d.y;
  } else {
    const f = chooseBestFlower(p.x, p.y);
    if(f){ tx = f.x; ty = f.y; }
  }

  const dir = vecNorm(tx - p.x, ty - p.y);

  let sx = dir.x + avoidX;
  let sy = dir.y + avoidY;

  const out = vecNorm(sx, sy);

  const stopRadius = 14;
  const distToTarget = Math.hypot(tx - p.x, ty - p.y);

  if(state.autoMode === "hiveHold" && distToTarget <= stopRadius){
    return;
  }

  p.x += out.x * state.moveSpeed * dt;
  p.y += out.y * state.moveSpeed * dt;

  p.x = clamp(p.x, 20, canvas.width - 20);
  p.y = clamp(p.y, 20, canvas.height - 20);
}

function autoBuyTick(ts){
  if(!state.autoPlay) return;
  if(state.instaOwned) return;
  if(ts - state.lastAutoBuyTs < 600) return;
  state.lastAutoBuyTs = ts;

  if(allBadgesDone() && !state.instaOwned){
    if(Math.floor(state.honey) >= INSTA_ITEM_PRICE){
      buyItem(INSTA_ITEM_ID);
    }
    return;
  }

  const honey = Math.floor(state.honey);
  const cands = [];

  for(const it of shopItems){
    if(it.maxed && it.maxed()) continue;
    const price = it.price();
    if(honey < price) continue;

    let util = 1;

    if(it.id === "gather") util = 6 * 1.25;
    if(it.id === "cap") util = 15 * (state.gatherRate / 80);
    if(it.id === "speed") util = 25 * 0.22;
    if(it.id === "bee") {
      const conv = 8 * 0.7;
      const dmg = state.beePower * 0.55 * 1.0;
      util = (conv + dmg) * 2.1;
      if(state.bees === 0) util *= 1.6;
    }
    if(it.id === "beePower") {
      const dmg = Math.max(1, state.bees) * 0.55 * 3;
      util = dmg * 1.8;
      if(state.bees === 0) util *= 0.35;
    }
    if(it.id === "watering") {
      const next = state.wateringLevel + 1;
      const curM = WATER_MULTS[state.wateringLevel] || 1.0;
      const nextM = WATER_MULTS[next] || curM;
      const delta = Math.max(0, nextM - curM);
      util = delta * 55;
    }

    const score = util / Math.max(1, price);
    cands.push({ id: it.id, score });
  }

  cands.sort((a,b) => b.score - a.score);
  if(cands.length){
    buyItem(cands[0].id);
  }
}

function step(dt, ts){
  if(state.autoPlay){
    aiSteer(dt, ts);
  } else {
    const p = state.player;
    let vx = 0, vy = 0;
    if(state.keys.left) vx -= 1;
    if(state.keys.right) vx += 1;
    if(state.keys.up) vy -= 1;
    if(state.keys.down) vy += 1;
    const len = Math.hypot(vx, vy) || 1;
    vx /= len; vy /= len;
    p.x += vx * state.moveSpeed * dt;
    p.y += vy * state.moveSpeed * dt;
    p.x = clamp(p.x, 20, canvas.width - 20);
    p.y = clamp(p.y, 20, canvas.height - 20);
  }

  for(const f of state.flowers){
    f.pollen = clamp(f.pollen + f.regen * (state.wateringMult || 1.0) * dt, 0, f.max);
  }

  const p = state.player;

  const near = nearestFlower(p.x, p.y);
  if(near.f){
    const f = near.f;
    const range = (p.r + f.r + 12);
    const inRange = near.d2 <= range * range;
    if(inRange){
      const baseRate = state.gatherRate;
      const beeRate = state.bees * state.beePower;
      const manualBoost = state.keys.space ? 1.8 : 1.0;
      const autoBoost = state.autoPlay ? 1.6 : 1.0;
      const total = (baseRate * manualBoost * autoBoost + beeRate) * dt;
      if(state.pollen < state.pollenCap && f.pollen > 0){
        const take = Math.min(total, state.pollenCap - state.pollen, f.pollen);
        f.pollen -= take;
        state.pollen += take;
      }
    }
  }

  const h = state.hive;
  const hiveRange = (p.r + h.r + 12);
  const inHive = dist2(p.x, p.y, h.x, h.y) <= hiveRange * hiveRange;

  if(inHive && state.pollen > 0){
    if(state.instaOwned && state.instaEnabled){
      const convert = state.pollen;
      state.pollen -= convert;
      addHoney(convert, "convert");
    } else {
      const convertRate = 35 + state.bees * 8;
      const convert = Math.min(state.pollen, convertRate * dt);
      state.pollen -= convert;
      addHoney(convert, "convert");
    }
  }

  const mantisEnabled = state.bees > 0;

  if(!mantisEnabled){
    if(state.lastMantisSpawnTs === 0) state.lastMantisSpawnTs = ts;
  } else {
    if(state.mobs.length === 0){
      if(state.lastMantisSpawnTs === 0) state.lastMantisSpawnTs = ts;
      if(ts - state.lastMantisSpawnTs >= state.mantisCooldownMs){
        spawnMantis(ts, 120);
      }
    }

    for(const m of state.mobs){
      m.wobble += dt * 1.3;

      const toX = p.x - m.x;
      const toY = p.y - m.y;
      const d = Math.hypot(toX, toY) || 1;

      const ax = (toX / d);
      const ay = (toY / d);

      const wiggleX = Math.cos(m.wobble) * 0.35;
      const wiggleY = Math.sin(m.wobble * 1.4) * 0.35;

      m.x += (ax + wiggleX) * m.speed * dt;
      m.y += (ay + wiggleY) * m.speed * dt;

      m.x = clamp(m.x, 220, canvas.width - 20);
      m.y = clamp(m.y, 70, canvas.height - 20);

      const hitRange = p.r + m.r + 6;
      if(dist2(p.x, p.y, m.x, m.y) <= hitRange * hitRange){
        const shove = 220;
        p.x = clamp(p.x - ax * shove * dt, 20, canvas.width - 20);
        p.y = clamp(p.y - ay * shove * dt, 20, canvas.height - 20);
      }
    }
  }

  if(state.bees > 0 && state.mobs.length > 0){
    const { m, d2 } = nearestMob(p.x, p.y);
    if(m){
      const attackRange = 220;
      if(d2 <= attackRange * attackRange){
        const dps = (state.bees * state.beePower) * 0.55;
        m.hp -= dps * dt;
        if(m.hp <= 0){
          for(let i=0; i<2 + Math.floor(Math.random() * 2); i++){
            dropHoney(m.x + (Math.random()*14 - 7), m.y + (Math.random()*14 - 7));
          }
          state.mobs = state.mobs.filter(x => x !== m);
          state.lastMantisSpawnTs = ts;
        }
      }
    }
  }

  const now = performance.now();

  for(const d of state.drops){
    d.r = 10 + Math.sin((now - d.born) / 180) * 1.5;
  }

  state.drops = state.drops.filter(d => (now - d.born) <= d.ttl);

  for(const d of state.drops){
    const pickRange = state.player.r + d.r + 6;
    if(dist2(p.x, p.y, d.x, d.y) <= pickRange * pickRange){
      addHoney(d.amount, "drops");
      d.ttl = 0;
    }
  }

  state.drops = state.drops.filter(d => d.ttl > 0);

  autoBuyTick(ts);

  syncUI(false);

  if(ts - state.lastAutoSave > 2500){
    state.lastAutoSave = ts;
    persist();
  }
}

function tick(ts){
  const dt = state.lastTs ? Math.min(0.05, (ts - state.lastTs) / 1000) : 0;
  state.lastTs = ts;
  if(state.running && !state.paused){
    step(dt, ts);
  } else {
    syncUI(false);
  }
  draw(ts);
  drawHUD();
  requestAnimationFrame(tick);
}

function draw(ts){
  const W = canvas.width;
  const H = canvas.height;

  ctx.clearRect(0, 0, W, H);

  const g = ctx.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, "rgba(255,255,255,.06)");
  g.addColorStop(1, "rgba(255,255,255,.02)");
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);

  ctx.strokeStyle = "rgba(255,255,255,.05)";
  ctx.lineWidth = 1;
  for(let x=0; x<=W; x+=40){
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  for(let y=0; y<=H; y+=40){
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }

  drawHive();
  for(const f of state.flowers) drawFlower(f);
  drawDrops(ts);
  drawMobs();
  drawBees(ts);
  drawPlayer();
}

function drawHUD(){
  const hud = $("#hudPanel");
  if(!hud) return;

  let mantisLine = t("mantisInactive");
  if(state.bees > 0){
    const now = performance.now();
    const cd = Math.max(0, state.mantisCooldownMs - (now - state.lastMantisSpawnTs));
    const cdS = Math.ceil(cd / 1000);
    mantisLine = state.mobs.length ? t("mantisInField") : t("mantisCd", { s: cdS });
  }

  const instaLine = (state.instaOwned && state.instaEnabled) ? t("instaHudOn") : t("instaHudOff");
  const autoLine = state.autoPlay ? t("autoOn") : t("autoOff");

  hud.innerHTML = `
    <div class="row" style="gap:8px">
      <span class="pill">${t("pollen")} <b>${fmtInt(state.pollen)}</b>/<b>${fmtInt(state.pollenCap)}</b></span>
      <span class="pill">${t("honey")} <b>${fmtInt(state.honey)}</b></span>
      <span class="pill">${t("bees")} <b>${fmtInt(state.bees)}</b></span>
      <span class="pill"><b>${mantisLine}</b></span>
      <span class="pill"><b>${instaLine}</b></span>
      <span class="pill"><b>${autoLine}</b></span>
    </div>
  `;
}

function drawHive(){
  const h = state.hive;

  ctx.save();
  ctx.translate(h.x, h.y);

  ctx.beginPath();
  ctx.arc(0, 0, h.r + 10, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(251,191,36,.08)";
  ctx.fill();

  ctx.beginPath();
  ctx.arc(0, 0, h.r, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(251,191,36,.22)";
  ctx.fill();

  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(251,191,36,.55)";
  ctx.stroke();

  ctx.fillStyle = "rgba(229,231,235,.88)";
  ctx.font = "800 12px ui-sans-serif";
  ctx.textAlign = "center";
  ctx.fillText(t("hive"), 0, -24);

  if(state.instaOwned && state.instaEnabled){
    ctx.fillStyle = "rgba(52,211,153,.9)";
    ctx.font = "900 11px ui-sans-serif";
    ctx.fillText("INSTA", 0, -36);
  }

  ctx.restore();
}

function drawFlower(f){
  const pct = f.pollen / f.max;
  let core = "rgba(96,165,250,.20)";
  let ring = "rgba(96,165,250,.58)";
  if(f.rarity === "rare") { core = "rgba(52,211,153,.18)"; ring = "rgba(52,211,153,.60)"; }
  if(f.rarity === "epic") { core = "rgba(251,191,36,.16)"; ring = "rgba(251,191,36,.68)"; }
  if(f.rarity === "legendary") { core = "rgba(167,139,250,.16)"; ring = "rgba(167,139,250,.72)"; }

  ctx.save();
  ctx.translate(f.x, f.y);

  ctx.beginPath();
  ctx.arc(0, 0, f.r + 10, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(255,255,255,.03)";
  ctx.fill();

  ctx.beginPath();
  ctx.arc(0, 0, f.r, 0, Math.PI * 2);
  ctx.fillStyle = core;
  ctx.fill();

  ctx.lineWidth = 2;
  ctx.strokeStyle = ring;
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(0, 0, f.r + 6, -Math.PI/2, -Math.PI/2 + Math.PI*2*pct);
  ctx.strokeStyle = "rgba(255,255,255,.22)";
  ctx.lineWidth = 3;
  ctx.stroke();

  ctx.restore();
}

function drawPlayer(){
  const p = state.player;

  ctx.save();
  ctx.translate(p.x, p.y);

  ctx.beginPath();
  ctx.arc(0, 0, p.r + 12, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(96,165,250,.08)";
  ctx.fill();

  ctx.beginPath();
  ctx.ellipse(0, 0, p.r + 6, p.r + 2, 0, 0, Math.PI*2);
  ctx.fillStyle = "rgba(96,165,250,.18)";
  ctx.fill();

  ctx.beginPath();
  ctx.arc(0, 0, p.r, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(229,231,235,.16)";
  ctx.fill();

  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(96,165,250,.55)";
  ctx.stroke();

  ctx.fillStyle = "rgba(229,231,235,.92)";
  ctx.font = "900 12px ui-sans-serif";
  ctx.textAlign = "center";
  ctx.fillText(t("you"), 0, 4);

  ctx.restore();
}

function drawBees(ts){
  const p = state.player;
  const count = state.bees;
  if(count <= 0) return;

  const time = (ts || performance.now()) / 1000;

  let target = null;
  if(state.mobs.length){
    const nm = nearestMob(p.x, p.y);
    if(nm.m && nm.d2 <= 220*220) target = nm.m;
  }

  for(let i=0; i<count; i++){
    const a = time * 1.8 + i * (Math.PI * 2 / count);
    const r = 26 + (i % 3) * 8;

    const bx = p.x + Math.cos(a) * r;
    const by = p.y + Math.sin(a) * (r * 0.75);

    ctx.save();
    ctx.translate(bx, by);

    ctx.beginPath();
    ctx.ellipse(0, 0, 9, 7, 0, 0, Math.PI*2);
    ctx.fillStyle = "rgba(251,191,36,.22)";
    ctx.fill();

    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(251,191,36,.65)";
    ctx.stroke();

    ctx.beginPath();
    ctx.ellipse(-3, -7, 6, 4, -0.35, 0, Math.PI*2);
    ctx.ellipse(3, -7, 6, 4, 0.35, 0, Math.PI*2);
    ctx.fillStyle = "rgba(229,231,235,.18)";
    ctx.fill();

    ctx.restore();

    if(target && i % 4 === 0){
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(bx, by);
      ctx.lineTo(target.x, target.y);
      ctx.strokeStyle = "rgba(251,191,36,.08)";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }
  }
}

function drawMobs(){
  for(const m of state.mobs){
    if(m.type !== "mantis") continue;

    ctx.save();
    ctx.translate(m.x, m.y);

    ctx.beginPath();
    ctx.arc(0, 0, m.r + 14, 0, Math.PI*2);
    ctx.fillStyle = "rgba(52,211,153,.06)";
    ctx.fill();

    ctx.beginPath();
    ctx.ellipse(0, 0, m.r + 2, m.r - 1, 0.2, 0, Math.PI*2);
    ctx.fillStyle = "rgba(52,211,153,.18)";
    ctx.fill();

    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(52,211,153,.55)";
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-8, 6);
    ctx.lineTo(-18, 18);
    ctx.moveTo(8, 6);
    ctx.lineTo(18, 18);
    ctx.strokeStyle = "rgba(52,211,153,.35)";
    ctx.lineWidth = 3;
    ctx.stroke();

    const barW = 44;
    const barH = 6;
    const pct = clamp(m.hp / m.hpMax, 0, 1);

    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.fillRect(-barW/2, -m.r - 18, barW, barH);

    ctx.fillStyle = "rgba(52,211,153,.75)";
    ctx.fillRect(-barW/2, -m.r - 18, barW * pct, barH);

    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.strokeRect(-barW/2 + .5, -m.r - 18 + .5, barW - 1, barH - 1);

    ctx.restore();
  }
}

function drawDrops(ts){
  const time = (ts || performance.now());
  for(const d of state.drops){
    const pulse = 1 + Math.sin((time - d.born) / 220) * 0.08;
    ctx.save();
    ctx.translate(d.x, d.y);
    ctx.scale(pulse, pulse);

    ctx.beginPath();
    ctx.arc(0, 0, d.r + 9, 0, Math.PI*2);
    ctx.fillStyle = "rgba(251,191,36,.08)";
    ctx.fill();

    ctx.beginPath();
    ctx.arc(0, 0, d.r, 0, Math.PI*2);
    ctx.fillStyle = "rgba(251,191,36,.24)";
    ctx.fill();

    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(251,191,36,.65)";
    ctx.stroke();

    ctx.fillStyle = "rgba(229,231,235,.88)";
    ctx.font = "800 11px ui-sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("+" + fmtInt(d.amount), 0, 4);

    ctx.restore();
  }
}

function keyToAction(e){
  const code = e.code;
  if(code === "ArrowLeft" || code === "KeyA") return "left";
  if(code === "ArrowRight" || code === "KeyD") return "right";
  if(code === "ArrowUp" || code === "KeyW") return "up";
  if(code === "ArrowDown" || code === "KeyS") return "down";
  if(code === "Space") return "space";
  return null;
}

function bindControls(){
  canvas.addEventListener("pointerdown", () => canvas.focus({ preventScroll:true }));

  document.addEventListener("keydown", (e) => {
    const act = keyToAction(e);
    if(!act) return;
    state.keys[act] = true;
    e.preventDefault();
  }, { passive:false, capture:true });

  document.addEventListener("keyup", (e) => {
    const act = keyToAction(e);
    if(!act) return;
    state.keys[act] = false;
    e.preventDefault();
  }, { passive:false, capture:true });

  window.addEventListener("blur", () => {
    state.keys.left = false;
    state.keys.right = false;
    state.keys.up = false;
    state.keys.down = false;
    state.keys.space = false;
  });
}

function setAdminVisible(v){
  $("#adminWrap").style.display = v ? "" : "none";
  if(v) $("#adminHoney").focus({ preventScroll:true });
}

function adminStatusOk(msg){
  const s = $("#adminStatus");
  s.className = "status good";
  s.textContent = msg;
}

function adminStatusBad(msg){
  const s = $("#adminStatus");
  s.className = "status bad";
  s.textContent = msg;
}

function giveHoney(amount){
  const n = Math.floor(Number(amount) || 0);
  if(n <= 0) return false;
  addHoney(n, "admin");
  persist();
  syncUI(true);
  return true;
}

function adminSpawnMantis(count, hp){
  const c = clamp(Math.floor(Number(count) || 0), 1, ADMIN_MANTIS_MAX);
  const h = clamp(Math.floor(Number(hp) || 0), 1, 50000);
  const ts = performance.now();
  for(let i=0; i<c; i++) spawnMantis(ts, h);
  persist();
  syncUI(true);
  return { c, h };
}

function buyItem(id){
  const honey = Math.floor(state.honey);

  if(id === INSTA_ITEM_ID){
    if(!allBadgesDone()) return;
    if(state.instaOwned) return;
    if(honey < INSTA_ITEM_PRICE) return;

    state.honey -= INSTA_ITEM_PRICE;
    state.stats.honeySpent += INSTA_ITEM_PRICE;
    state.instaOwned = true;
    state.instaEnabled = true;

    persist();
    syncUI(true);

    $("#shopStatus").className = "status good";
    $("#shopStatus").textContent = t("bought", { name: t("instaName") });
    return;
  }

  const item = shopItems.find(x => x.id === id);
  if(!item) return;
  if(item.maxed && item.maxed()) return;

  const price = item.price();
  if(honey < price) return;

  state.honey -= price;
  state.stats.honeySpent += price;
  item.buy();

  persist();
  syncUI(true);

  $("#shopStatus").className = "status good";
  $("#shopStatus").textContent = t("bought", { name: t(item.nameKey) });
}

function toggleInsta(){
  if(!state.instaOwned) return;
  state.instaEnabled = !state.instaEnabled;
  persist();
  syncUI(true);
}

function bindUI(){
  $("#btnStart").addEventListener("click", () => {
    state.running = true;
    state.paused = false;
    state.lastTs = 0;
    if(state.lastMantisSpawnTs === 0) state.lastMantisSpawnTs = performance.now();
    updatePlayStatus();
    canvas.focus({ preventScroll:true });
    syncUI(true);
  });

  $("#btnPause").addEventListener("click", () => {
    if(!state.running) return;
    state.paused = !state.paused;
    updatePlayStatus();
    syncUI(true);
  });

  $("#btnAuto").addEventListener("click", () => {
    state.autoPlay = !state.autoPlay;
    $("#btnAuto").textContent = state.autoPlay ? t("autoOn") : t("autoOff");
    updatePlayStatus();
    persist();
  });

  $("#btnReset").addEventListener("click", () => {
    if(confirm(state.lang === "ru" ? "Сбросить прогресс?" : "Reset progress?")){
      localStorage.removeItem(STORE_KEY);
      location.reload();
    }
  });

  $("#btnSave").addEventListener("click", () => {
    persist();
    $("#shopStatus").className = "status good";
    $("#shopStatus").textContent = t("saved");
    syncUI(true);
  });

  $("#shopBody").addEventListener("click", (e) => {
    const btnBuy = e.target.closest("button[data-buy]");
    if(btnBuy){
      buyItem(btnBuy.dataset.buy);
      return;
    }
    const btnToggle = e.target.closest("button[data-toggle-insta]");
    if(btnToggle){
      toggleInsta();
      return;
    }
  });

  window.addEventListener("resize", () => {
    resizeCanvas();
    seedField();
    syncUI(true);
  });

  $("#tabShop").addEventListener("click", () => setTab("shop"));
  $("#tabBadges").addEventListener("click", () => setTab("badges"));

  document.addEventListener("keydown", (e) => {
    if(e.ctrlKey && e.shiftKey && e.code === "KeyA"){
      e.preventDefault();
      const shown = $("#adminWrap").style.display !== "none" && $("#adminWrap").style.display !== "";
      setAdminVisible(!shown);
    }
  });

  $("#btnAdminClose").addEventListener("click", () => {
    setAdminVisible(false);
    canvas.focus({ preventScroll:true });
  });

  $("#btnGiveHoney").addEventListener("click", () => {
    const val = $("#adminHoney").value;
    const ok = giveHoney(val);
    if(ok){
      adminStatusOk(t("adminOkHoney", { n: fmtInt(val) }));
      $("#adminHoney").value = "";
    } else {
      adminStatusBad(t("adminBadHoney"));
    }
  });

  $("#btnSpawnMantis").addEventListener("click", () => {
    const count = $("#adminMantisCount").value || 1;
    const hp = $("#adminMantisHp").value || 120;
    const r = adminSpawnMantis(count, hp);
    adminStatusOk(t("adminOkSpawn", { c: r.c, h: r.h }));
  });

  $("#langSelect").addEventListener("change", () => {
    const v = $("#langSelect").value;
    state.lang = (v === "en") ? "en" : "ru";
    setStaticText();
    renderShop();
    renderBadges();
    syncUI(true);
    persist();
  });
}

function init(){
  resizeCanvas();
  load();
  $("#langSelect").value = state.lang;
  setStaticText();
  seedField();
  renderShop();
  renderBadges();
  syncUI(true);
  bindControls();
  bindUI();
  updatePlayStatus();
  requestAnimationFrame(tick);
}

init();
</script>
</body>
</html>
